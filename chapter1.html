<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="src/output.css" />
    <title>Document</title>
  </head>
  <body class="bg-[#0C2B4E] font-serif">
    <header id="#Top" class="fixed top-0 left-0 w-full shadow-md text-center p-3 pl-0 pr-0 bg-gradient-to-b from-blue-400 to-blue-100 z-50">

      <a href="index.html">
        <div class="fixed flex gap-2 p-3 pb-1 pt-1 m-5 mt-1 rounded-2xl
        hover:-translate-y-2 hover:border-blue-500 border  transition-all duration-300">
          <img src="imagesChapter1/arrow.png" alt="" width="15px" height="7px"> 
          <h1>back</h1>
        </div>
        
        <div class="gap-5 text-center">
            <h1 class="text-3xl font-bold text-black font-sans">CHAPTER 1</h1>
            <h1 class="text-3xl font-bold">INTRODUCTION</h1>
        </div>
        <h1 class="pt-3 font-semibold text-gray-800 ">TOPICS</h1>
      </a>

      <!-- Michelle Daluz -->

      <nav class="nav"> 
        <a class="link" href="#part1">1.1 Professional Software Development</a>
        <a class="link" href="#part2">1.2 Software Engineering Ethics</a>
        <a class="link" href="#part3">1.3 Case Studies</a>
        
      </nav>
    </header>
<main class="bg-[#B9EBFF]">  
      <section class="bg-[#B9EBFF] p-5 pb-2">
        <article
          id="part1"
          class="bg-ivory-500 scroll-mt-80 parts mt-63 md:mt-50 md:scroll-mt-90 lg:mt-45 xl:mt-45"
        >
          <h2 class="border font-serif shadow-lg p-4 mb-5 w-full text-center">
            1.1 Professional Software Development
          </h2>

          <p class="paragraph">
            Many people write programs for personal or professional use, but most software is developed professionally by teams for business or products. Professional software development involves not just writing code but also documentation, configuration, design, and ongoing maintenance so others can use and improve it. This distinguishes it from personal programming, where such extra effort is unnecessary.
          </p>
          <figure class="figure">
              <img
                src="imagesChapter1/image1.png"
                alt="Figure 1.1 Frequently asked questions about software"
                height="300px"
                class="mx-auto"
              />
              <figcaption class="text-center mt-2">
                Figure 1.1 Frequently asked questions about software
              </figcaption>
            </figure>
        <h2 class="mb-3">
           Software engineers are concerned with developing software products (i.e., software which can be sold to a customer). There are two kinds of software products:
          </h2>
        <ol class="p-5 mb-3">
            <li>
              Generic products - These are stand-alone systems that are produced by a development organization and sold on the open market to any customer who is able to buy them. Examples of this type of product include software for PCs such as databases, word processors, drawing packages, and project-management tools. It also includes so-called vertical applications designed for some specific purpose such as library information systems, accounting systems, or systems for maintaining dental records.
            </li>
            <br><li>
              Customized (or bespoke) products - 
                These are systems that are commissioned by a particular customer. A software contractor develops the software especially for that customer. Examples of this type of software include control systems for electronic devices, systems written to support a particular business process, and air traffic control systems.
                <br><br><p>An important difference between these types of software is that, in generic products, the organization that develops the software controls the software specification. For custom products, the specification is usually developed and controlled by the organization that is buying the software. The software developers must work to that specification.</p>
                <br><p>However, the distinction between these system product types is becoming increasingly blurred. More and more systems are now being built with a generic product as a base, which is then adapted to suit the requirements of a customer. Enterprise Resource Planning (ERP) systems, such as the SAP system, are the best examples of this approach. Here, a large and complex system is adapted for a company by incorporating information about business rules and processes, reports required, and so on.</p>
                <br><p>When we talk about the quality of professional software, we have to take into account that the software is used and changed by people apart from its developers. Quality is therefore not just concerned with what the software does. Rather, it has to include the software’s behavior while it is executing and the structure and organization of the system programs and associated documentation. This is reflected in so-called quality or non-functional software attributes. Examples of these attributes are the software’s response time to a user query and the understandability of the program code.</p>
                <br><p>The specific set of attributes that you might expect from a software system obviously depends on its application. Therefore, a banking system must be secure, an interactive game must be responsive, a telephone switching system must be reliable, and so on. These can be generalized into the set of attributes shown in Figure 1.2, which I believe are the essential characteristics of a professional software system.</p>
            </li>
          </ol>
          <article
          class="bg-ivory-500 scroll-mt-80 parts mt-63 md:mt-50 md:scroll-mt-90 lg:mt-45 xl:mt-45">
          <h2 class="border rounded-2xl shadow-lg p-4 mb-5 w-full text-center">
            1.1.1 Software Engineering
          </h2>
          <h2 class="mb-3">
           Software engineering is an engineering discipline that is concerned with all aspects of software production from the early stages of system specification through to maintaining the system after it has gone into use. In this definition, there are two key phrases:
          </h2>
          <ol class="p-5 mb-3">
            <li>
              Engineering discipline Engineers make things work. They apply theories, methods, and tools where these are appropriate. However, they use them selectively and always try to discover solutions to problems even when there are no applicable theories and methods. Engineers also recognize that they must work to organizational and financial constraints so they look for solutions within these constraints.
            </li>
        </ol>
        <figure class="figure">
              <img
                src="imagesChapter1/image3.png"
                alt="Figure 1.2 Essential attributes of good software"
                height="300px"
                class="mx-auto"
              />
              <figcaption class="text-center mt-2">
                Figure 1.2 Essential attributes of good software
              </figcaption>
            </figure>
            
                <br>All aspects of software production Software engineering is not just concerned with the technical processes of software development. It also includes activities such as software project management and the development of tools, methods, and theories to support software production.
                <br><br><p>Engineering is about getting results of the required quality within the schedule and budget. This often involves making compromises—engineers cannot be perfectionists. People writing programs for themselves, however, can spend as much time as they wish on the program development.</p>
                <br><p>In general, software engineers adopt a systematic and organized approach to their work, as this is often the most effective way to produce high-quality software. However, engineering is all about selecting the most appropriate method for a set of circumstances so a more creative, less formal approach to development may be effective in some circumstances. Less formal development is particularly appropriate for the development of web-based systems, which requires a blend of software and graphical design skills.</p>
        <br><h2 class="mb-3">
           Software engineering is important for two reasons:
          </h2>
        <ol class="p-5 mb-3">
            <li>
              More and more, individuals and society rely on advanced software systems. We need to be able to produce reliable and trustworthy systems economically and quickly.
            </li>
            <br><li>
              It is usually cheaper, in the long run, to use software engineering methods and techniques for software systems rather than just write the programs as if it was a personal programming project. For most types of systems, the majority of costs are the costs of changing the software after it has gone into use.
            </li>
            <br><p>The systematic approach that is used in software engineering is sometimes called a software process. A software process is a sequence of activities that leads to the production of a software product.
            </p>
        </ol>
        <br><h2 class="mb-3">
           There are four fundamental activities that are common to all software processes. These activities are:
          </h2>
        <ol class="p-5 mb-3">
            <li>
              Software specification, where customers and engineers define the software that is to be produced and the constraints on its operation.
            </li>
            <br><li>
              Software development, where the software is designed and programmed.
            </li>
            <br><li>
              Software validation, where the software is checked to ensure that it is what the customer requires.
            </li>
            <br><li>Software evolution, where the software is modified to reflect changing customer and market requirements.
            </li>
            <br><p>Different types of systems need different development processes. For example, real-time software in an aircraft has to be completely specified before development begins. In e-commerce systems, the specification and the program are usually developed together. Consequently, these generic activities may be organized in different ways and described at different levels of detail depending on the type of software being developed. I describe software processes in more detail in Chapter 2.
            </p>
        </ol>
        <br><h2 class="mb-3">
           Software engineering is related to both computer science and systems engineering:
          </h2>
        <ol class="p-5 mb-3">
        <br><li>Computer science is concerned with the theories and methods that underlie computers and software systems, whereas software engineering is concerned with the practical problems of producing software. Some knowledge of computer science is essential for software engineers in the same way that some knowledge of physics is essential for electrical engineers. Computer science theory, however, is often most applicable to relatively small programs. Elegant theories of computer science cannot always be applied to large, complex problems that require a software solution.
        </li>
        <br><li>System engineering is concerned with all aspects of the development and evolution of complex systems where software plays a major role. System engineering is therefore concerned with hardware development, policy and process design and system deployment, as well as software engineering. System engineers are involved in specifying the system, defining its overall architecture, and then integrating the different parts to create the finished system. They are less concerned with the engineering of the system components (hardware,software, etc.)
        </li>
        <br><p>
            As I discuss in the next section, there are many different types of software. There is no universal software engineering method or technique that is applicable for all of these.
        </p>
        </ol>
        <br><h2 class="mb-3">
           However, there are three general issues that affect many different types of software:
        </h2>
        <ol class="p-5 mb-3">
        <br><li>
            <b>Heterogeneity –</b> Increasingly, systems are required to operate as distributed systems across networks that include different types of computer and mobile devices. As well as running on general-purpose computers, software may also have to execute on mobile phones. You often have to integrate new software with older legacy systems written in different programming languages. The challenge here is to develop techniques for building dependable software that is flexible enough to cope with this heterogeneity.
        </li>
        <br><li>
            <b>Business and social change –</b>Business and society are changing incredibly quickly as emerging economies develop and new technologies become available. They need to be able to change their existing software and to rapidly develop new software. Many traditional software engineering techniques are time-consuming and delivery of new systems often takes longer than planned. They need to evolve so that the time required for software to deliver value to its customers is reduced.
        </li>
        <br><li>
            <b>Security and trust – </b>As software is intertwined with all aspects of our lives, it is essential that we can trust that software. This is especially true for remote software systems accessed through a web page or web service interface. We have to make sure that malicious users cannot attack our software and that information security is maintained.
        </li>
        <br><p>
            Of course, these are not independent issues. For example, it may be necessary to make rapid changes to a legacy system to provide it with a web service interface. To address these challenges we will need new tools and techniques as well as innovative ways of combining and using existing software engineering methods.
        </p>
        </ol>
        <article
          
          class="bg-ivory-500 scroll-mt-80 parts mt-63 md:mt-50 md:scroll-mt-90 lg:mt-45 xl:mt-45"
        >
          <h2 class="border rounded-2xl shadow-lg p-4 mb-5 w-full text-center">
            1.1.2 Software Engineering
          </h2>
        <p class="paragraph">
            Software engineering is a systematic approach to the production of software that takes into account practical cost, schedule, and dependability issues, as well as the needs of software customers and producers. How this systematic approach is actually implemented varies dramatically depending on the organization developing the software, the type of software, and the people involved in the development process. There are no universal software engineering methods and techniques that are suitable for all systems and all companies. Rather, a diverse set of software engineering methods and tools has evolved over the past 50 years.
        </p>
        <p class="paragraph">
            Perhaps the most significant factor in determining which software engineering methods and techniques are most important is the type of application that is being developed.
        </p>
        <br><h2 class="mb-3">
           There are four fundamental activities that are common to all software processes. These activities are:
        </h2>
        <ol class="p-5 mb-3">
        <br><li>Computer science is concerned with the theories and methods that underlie computers and software systems, whereas software engineering is concerned with the practical problems of producing software. Some knowledge of computer science is essential for software engineers in the same way that some knowledge of physics is essential for electrical engineers. Computer science theory, however, is often most applicable to relatively small programs. Elegant theories of computer science cannot always be applied to large, complex problems that require a software solution.
        </li>
        <ol class="p-5 mb-3">
    <br><li>
        <b>Stand-alone applications –</b> These are application systems that run on a local computer, such as a PC. They include all necessary functionality and do not need to be connected to a network. Examples of such applications are office applications on a PC, CAD programs, photo manipulation software, etc.
    </li>
    <br><li>
        <b>Interactive transaction-based applications –</b> These are applications that execute on a remote computer and that are accessed by users from their own PCs or terminals. Obviously, these include web applications such as e-commerce applications where you can interact with a remote system to buy goods and services. This class of application also includes business systems, where a business provides access to its systems through a web browser or special-purpose client program and cloud-based services, such as mail and photo sharing. Interactive applications often incorporate a large data store that is accessed and updated in each transaction.
    </li>
    <br><li>
        <b>Embedded control systems –</b> These are software control systems that control and manage hardware devices. Numerically, there are probably more embedded systems than any other type of system. Examples of embedded systems include the software in a mobile (cell) phone, software that controls anti-lock braking in a car, and software in a microwave oven to control the cooking process.
    </li>
    <br><li>
        <b>Batch processing systems –</b> These are business systems that are designed to process data in large batches. They process large numbers of individual inputs to create corresponding outputs. Examples of batch systems include periodic billing systems, such as phone billing systems, and salary payment systems.
    </li>
    <br><li>
        <b>Entertainment systems –</b> These are systems that are primarily for personal use and which are intended to entertain the user. Most of these systems are games of one kind or another. The quality of the user interaction offered is the most important distinguishing characteristic of entertainment systems.
    </li>
    <br><li>
        <b>Systems for modeling and simulation –</b> These are systems that are developed by scientists and engineers to model physical processes or situations, which include many separate, interacting objects. These are often computationally intensive and require high-performance parallel systems for execution.
    </li>
    <br><li>
        <b>Data collection systems –</b> These are systems that collect data from their environment using a set of sensors and send that data to other systems for processing. The software has to interact with sensors and often is installed in a hostile environment such as inside an engine or in a remote location.
    </li>
    <br><li>
        <b>Systems of systems –</b> These are systems that are composed of a number of other software systems. Some of these may be generic software products, such as a spreadsheet program. Other systems in the assembly may be specially written for that environment.
    </li>
    <br><p>
        Of course, the boundaries between these system types are blurred. If you develop a game for a mobile (cell) phone, you have to take into account the same constraints (power, hardware interaction) as the developers of the phone software. Batch processing systems are often used in conjunction with web-based systems. For example, in a company, travel expense claims may be submitted through a web application but processed in a batch application for monthly payment.
    </p>
    <br><p>
        You use different software engineering techniques for each type of system because the software has quite different characteristics. For example, an embedded control system in an automobile is safety-critical and is burned into ROM when installed in the vehicle. It is therefore very expensive to change. Such a system needs very extensive verification and validation so that the chances of having to recall cars after sale to fix software problems are minimized. User interaction is minimal (or perhaps nonexistent) so there is no need to use a development process that relies on user interface prototyping.
    </p>
    <br><p>
        For a web-based system, an approach based on iterative development and delivery may be appropriate, with the system being composed of reusable components. However, such an approach may be impractical for a system of systems, where detailed specifications of the system interactions have to be specified in advance so that each system can be separately developed.
    </p>
</ol>
<br><h2 class="mb-3">
    Nevertheless, there are software engineering fundamentals that apply to all types of software system:
</h2>

<ol class="p-5 mb-3">
    <br><li>
        <b>Managed and understood development process –</b> They should be developed using a managed and understood development process. The organization developing the software should plan the development process and have clear ideas of what will be produced and when it will be completed. Of course, different processes are used for different types of software.
    </li>
    <br><li>
        <b>Dependability and performance –</b> Dependability and performance are important for all types of systems. Software should behave as expected, without failures and should be available for use when it is required. It should be safe in its operation and, as far as possible, should be secure against external attack. The system should perform efficiently and should not waste resources.
    </li>
    <br><li>
        <b>Understanding and managing requirements –</b> Understanding and managing the software specification and requirements (what the software should do) are important. You have to know what different customers and users of the system expect from it and you have to manage their expectations so that a useful system can be delivered within budget and to schedule.
    </li>
    <br><li>
        <b>Effective use of existing resources –</b> You should make as effective use as possible of existing resources. This means that, where appropriate, you should reuse software that has already been developed rather than write new software.
    </li>
    <br><p>
        These fundamental notions of process, dependability, requirements, management, and reuse are important themes of this book. Different methods reflect them in different ways but they underlie all professional software development.
    </p>
    <br><p>
        You should notice that these fundamentals do not cover implementation and programming. I don’t cover specific programming techniques in this book because these vary dramatically from one type of system to another. For example, a scripting language such as Ruby is used for web-based system programming but would be completely inappropriate for embedded systems engineering.
    </p>
</ol>
<article
  
  class="bg-ivory-500 scroll-mt-80 parts mt-63 md:mt-50 md:scroll-mt-90 lg:mt-45 xl:mt-45"
>
  <h2 class="border rounded-2xl shadow-lg p-4 mb-5 w-full text-center">
    1.1.3 Software Engineering and the Web
  </h2>

  <p class="paragraph">
    The evolution of the World Wide Web transformed software development.
    Initially used as an information store, the Web later enabled web-based
    systems accessed through browsers, reducing costs and simplifying upgrades.
    The rise of web services, cloud computing, and software as a service (SaaS)
    shifted business applications from local, monolithic programs to
    distributed, component-based systems. This revolutionized how software is
    organized and engineered.
  </p>

  <h2 class="mb-3 mt-5">For example:</h2>

  <ol class="p-5 mb-3">
    <br />
    <li>
      <b>Software reuse –</b> Software reuse has become the dominant approach
      for constructing web-based systems. When building these systems, you think
      about how you can assemble them from pre-existing software components and
      systems.
    </li>


    <br />
    <li>
      <b>Incremental development –</b> It is now generally recognized that it is
      impractical to specify all the requirements for such systems in advance.
      Web-based systems should be developed and delivered incrementally.
    </li>

    <br />
    <li>
      <b>Browser-constrained interfaces –</b> User interfaces are constrained by
      the capabilities of web browsers. Although technologies such as AJAX
      (Holdener, 2008) mean that rich interfaces can be created within a web
      browser, these technologies are still difficult to use. Web forms with
      local scripting are more commonly used. Application interfaces on
      web-based systems are often poorer than the specially designed user
      interfaces on PC system products.
    </li>
  </ol>

  <p class="paragraph mt-5">
    The fundamental ideas of software engineering, discussed in the previous
    section, apply to web-based software in the same way that they apply to
    other types of software system. Experience gained with large system
    development in the 20th century is still relevant to web-based software.
  </p>
</article>
<article
  id="part2"
  class="bg-ivory-500 scroll-mt-80 parts mt-63 md:mt-50 md:scroll-mt-90 lg:mt-45 xl:mt-45"
>
  <h2 class="border rounded-2xl shadow-lg p-4 mb-5 w-full text-center">
    1.2 Software Engineering Ethics
  </h2>

  <p class="paragraph">
    Like other engineering disciplines, software engineering is carried out within a
    social and legal framework that limits the freedom of people working in that area.
    As a software engineer, you must accept that your job involves wider responsibilities
    than simply the application of technical skills. You must also behave in an ethical
    and morally responsible way if you are to be respected as a professional engineer.
  </p>

  <p class="paragraph mt-5">
    It goes without saying that you should uphold normal standards of honesty and integrity.
    You should not use your skills and abilities to behave in a dishonest way or in a way that
    will bring disrepute to the software engineering profession. However, there are areas where
    standards of acceptable behavior are not bound by laws but by the more tenuous notion of
    professional responsibility. Some of these are:
  </p>

  <ol class="p-5 mb-3">
    <br />
    <li>
      <b>Confidentiality –</b> You should normally respect the confidentiality of your
      employers or clients irrespective of whether or not a formal confidentiality agreement
      has been signed.
    </li>

    <br />
    <li>
      <b>Competence –</b> You should not misrepresent your level of competence. You should not
      knowingly accept work that is outside your competence.
    </li>

    <br />
    <li>
      <b>Intellectual property rights –</b> You should be aware of local laws governing the use
      of intellectual property such as patents and copyright. You should be careful to ensure
      that the intellectual property of employers and clients is protected.
    </li>

    <br />
    <li>
      <b>Computer misuse –</b> You should not use your technical skills to misuse other people’s
      computers. Computer misuse ranges from relatively trivial (game playing on an employer’s
      machine, say) to extremely serious (dissemination of viruses or other malware).
    </li>
  </ol>
</article>
    <figure class="figure">
              <img
                src="imagesChapter1/image4.png"
                alt="Figure 1.3 The ACM/IEEE Code of Ethics (© IEEE/ACM 1999)"
                height="300px"
                class="mx-auto"
              />
              <figcaption class="text-center mt-2">
                Figure 1.3 The ACM/IEEE Code of Ethics (© IEEE/ACM 1999)
              </figcaption>
            </figure>
<p class="paragraph">
    Professional societies like <b>ACM</b>, <b>IEEE</b>, and the <b>British Computer Society</b> set
    ethical standards through codes of conduct that members must follow. The ACM and IEEE have
    collaborated to create a joint code of ethics, available in both short and detailed forms,
    which outline fundamental principles of ethical and professional practice.
  </p>

  <p class="paragraph mt-5">
    Software engineers play a vital role in many areas of society and have the power to do great
    good or harm. To ensure their work benefits society, they must follow a <b>Code of Ethics and
    Professional Practice</b>. This code includes eight principles that outline ethical responsibilities
    and obligations for all software engineers, from students to professionals, emphasizing care for
    people and integrity in the profession.
  </p>

  <p class="paragraph mt-5">
    Software engineers often face ethical dilemmas, such as disagreements with management,
    disclosure of project risks, or employer misconduct in safety-critical systems. These situations
    require careful judgment, balancing potential harm, responsibilities, and personal values.
    Ethical issues also arise in areas like military or nuclear projects, where openness between
    employers and employees is essential. While philosophical approaches to ethics exist, practical
    codes of conduct and real-world discussions are more effective for guiding professional
    responsibility in software engineering.
  </p>
    <article
  id="part3"
  class="bg-ivory-500 scroll-mt-80 parts mt-63 md:mt-50 md:scroll-mt-90 lg:mt-45 xl:mt-45"
>
  <h2 class="border rounded-2xl shadow-lg p-4 mb-5 w-full text-center">
    1.3 Case Studies
  </h2>

  <p class="paragraph">
    To illustrate software engineering concepts, examples from three different types of systems
    are used throughout this book. The reason for not using a single case study is that one of the
    key messages in software engineering is that practice depends on the type of systems being
    produced. Therefore, an appropriate example is chosen when discussing concepts such as
    safety and dependability, system modeling, and reuse.
  </p>

  <p class="paragraph mt-5">
    The three ty
    pes of systems used as case studies are:
  </p>

  <ol class="p-5 mb-3">
    <li>
      <b>Embedded system –</b> A system where the software controls a hardware device and is
      embedded within it. Issues in embedded systems typically include physical size,
      responsiveness, and power management. The example used here is a software system designed
      to control a medical device.
    </li>

    <li>
      <b>Information system –</b> A system whose primary purpose is to manage and provide access to
      a database of information. Issues in such systems include security, usability, privacy, and
      maintaining data integrity. The example used here is a medical records system.
    </li>

    <li>
      <b>Sensor-based data collection system –</b> A system whose main function is to collect data
      from sensors and process that data. The key requirements of such systems are reliability,
      even in harsh environmental conditions, and maintainability. The example used here is a
      wilderness weather station.
    </li>
</ol>

  <p class="paragraph mt-5">
    Each of these systems is introduced in this chapter, with more information about them
    available on the Web.
  </p>
</article>
    <article

  class="bg-ivory-500 scroll-mt-80 parts mt-10 md:mt-8 md:scroll-mt-90 lg:mt-6 xl:mt-6"
>
  <h2 class="border rounded-2xl shadow-lg p-4 mb-5 w-full text-center">
    1.3.1 An Insulin Pump Control System
  </h2>

  <p class="paragraph">
    An insulin pump is a medical system designed to mimic the pancreas by automatically delivering
    insulin to diabetic patients. Traditional treatment requires manual measurement of blood sugar
    and insulin injections, which can lead to risks of dangerously low or high glucose levels.
  </p>

  <p class="paragraph mt-4">
    Low glucose can cause brain malfunction, unconsciousness, or even death, while prolonged high
    glucose levels can damage vital organs.
  </p>

  <p class="paragraph mt-4">
    Advances in miniaturized sensors now allow automated systems that continuously monitor blood
    sugar and deliver precise insulin doses. These embedded software-controlled systems use
    microsensors to detect blood sugar, compute insulin needs, and activate a pump that delivers
    insulin through a permanently attached needle.
  </p>
</article>
        <figure class="figure">
              <img
                src="imagesChapter1/image5.png"
                alt="Figure 1.4 Insulin pump hardware"
                height="300px"
                class="mx-auto"
              />
              <figcaption class="text-center mt-2">
                Figure 1.4 Insulin pump hardware
              </figcaption>
            </figure>
        <figure class="figure">
              <img
                src="imagesChapter1/image6.png"
                alt="Figure 1.5 Activity model of the insulin pump"
                height="300px"
                class="mx-auto"
              />
              <figcaption class="text-center mt-2">
                Figure 1.5 Activity model of the insulin pump
              </figcaption>
            </figure>
        <p class="paragraph mt-5">
    Figure 1.4 shows the hardware components and organization of the insulin pump. To understand the
    examples in this book, all you need to know is that the blood sensor measures the electrical
    conductivity of the blood under different conditions and that these values can be related to the
    blood sugar level. The insulin pump delivers one unit of insulin in response to a single pulse
    from a controller. Therefore, to deliver 10 units of insulin, the controller sends 10 pulses to
    the pump. Figure 1.5 is a UML activity model that illustrates how the software transforms an
    input blood sugar level to a sequence of commands that drive the insulin pump.
  </p>

  <p class="paragraph mt-5">
    Clearly, this is a safety-critical system. If the pump fails to operate or does not operate
    correctly, then the user’s health may be damaged or they may fall into a coma because their
    blood sugar levels are too high or too low.
  </p>

  <p class="paragraph mt-5">
    There are, therefore, two essential high-level requirements that this system must meet:
  </p>

  <ol class="p-5 mb-3">
    <li>
      The system shall be available to deliver insulin when required.
    </li>
    <li>
      The system shall perform reliably and deliver the correct amount of insulin to counteract the
      current level of blood sugar.
    </li>
</ol>
        <figure class="figure">
              <img
                src="imagesChapter1/image7.png"
                alt="Figure 1.6 The organization of the MHC-PMS"
                height="300px"
                class="mx-auto"
              />
              <figcaption class="text-center mt-2">
                Figure 1.6 The organization of the MHC-PMS
              </figcaption>
            </figure>
        <br><p>The system must therefore be designed and implemented to ensure that the system always meets these requirements. More detailed requirements and discussions of how to ensure that the system is safe are discussed in later chapters.
        </p>
        <article

  class="bg-ivory-500 scroll-mt-80 parts mt-63 md:mt-50 md:scroll-mt-90 lg:mt-45 xl:mt-45"
>
  <h2 class="border rounded-2xl shadow-lg p-4 mb-5 w-full text-center">
    1.3.2 A Patient Information System for Mental Health Care
  </h2>

  <p class="paragraph">
    A patient information system to support mental health care is a medical information system that
    maintains information about patients suffering from mental health problems and the treatments
    that they have received. Most mental health patients do not require dedicated hospital
    treatment but need to attend specialist clinics regularly where they can meet a doctor who has
    detailed knowledge of their problems. To make it easier for patients to attend, these clinics
    are not just run in hospitals. They may also be held in local medical practices or community
    centers.
  </p>

  <p class="paragraph mt-5">
    The MHC-PMS (Mental Health Care–Patient Management System) is an information system intended for
    use in clinics. It makes use of a centralized database of patient information but has also been
    designed to run on a PC, so that it may be accessed and used from sites that do not have secure
    network connectivity. When the local systems have secure network access, they use patient
    information in the database but can download and use local copies of patient records when
    disconnected. The system is not a complete medical records system, so it does not maintain
    information about other medical conditions. However, it may interact and exchange data with
    other clinical information systems. Figure 1.6 illustrates the organization of the MHC-PMS.
  </p>

  <p class="paragraph mt-5">
    The MHC-PMS has two overall goals:
  </p>

  <ol class="p-5 mb-3">
    <li>
      To generate management information that allows health service managers to assess performance
      against local and government targets.
    </li>
    <li>
      To provide medical staff with timely information to support the treatment of patients.
    </li>
  </ol>

  <p class="paragraph mt-5">
    Mental health patients often face challenges such as missed appointments, lost prescriptions,
    forgetfulness, unreasonab le demands, frequent address changes, or homelessness. In some cases,
    they may pose risks to themselves or others, requiring secure hospitalization. The system
    supporting their care is used by medical staff (doctors, nurses, health visitors) and nonmedical
    staff (receptionists, records staff, administrators). It stores patient details, consultations,
    conditions, and treatments, while generating reports: detailed ones for medical staff and
    anonymized management reports for health authorities.
  </p>

  <p class="paragraph mt-5">
    The key features of the system are:
  </p>

  <ol class="p-5 mb-3">
    <li>
      <b>Individual care management –</b> Clinicians can create records for patients, edit
      information in the system, and view patient history. The system supports data summaries so
      that doctors who have not previously met a patient can quickly learn about key problems and
      treatments that have been prescribed.
    </li>
    <li>
      <b>Patient monitoring –</b> The system regularly monitors the records of patients involved in
      treatment and issues warnings if possible problems are detected. For example, if a patient has
      not seen a doctor for some time, a warning may be issued. One of the most important elements
      of the monitoring system is to track patients who have been sectioned and ensure that the
      legally required checks are carried out at the right time.
    </li>
    <li>
      <b>Administrative reporting –</b> The system generates monthly management reports showing the
      number of patients treated at each clinic, the number who have entered and left the care
      system, patients sectioned, drugs prescribed, and their costs.
    </li>
  </ol>

  <p class="paragraph mt-5">
    Two different laws affect the system: data protection laws that govern the confidentiality of
    personal information and mental health laws that govern the compulsory detention of patients
    deemed to be a danger to themselves or others. Mental health is unique in this respect, as it is
    the only medical specialty that can recommend the detention of patients against their will. This
    is subject to very strict legislative safeguards. One of the aims of the MHC-PMS is to ensure
    that staff always act in accordance with the law and that their decisions are recorded for
    judicial review if necessary.
  </p>

  <p class="paragraph mt-5"> 
    As in all medical systems, privacy is a critical system requirement. It is essential that patient
    information remains confidential and is never disclosed to anyone apart from authorized medical
    staff and the patient themselves. The MHC-PMS is also a safety-critical system. Some mental
    illnesses cause patients to become suicidal or a danger to others. Wherever possible, the system
    should warn medical staff about potentially suicidal or dangerous patients.
  </p>
</article>
<figure class="figure">
              <img
                src="imagesChapter1/image8.png"
                alt="Figure 1.7 The organization of the MHC-PMS"
                height="300px"
                class="mx-auto"
              />
              <figcaption class="text-center mt-2">
                Figure 1.7 The organization of the MHC-PMS
              </figcaption>
            </figure>
    <br><p>
        The overall design of the system has to take into account privacy and safety requirements. The system must be available when needed; otherwise, safety may be compromised and it may be impossible to prescribe the correct medication to patients. There is a potential conflict here — privacy is easiest to maintain when there is only a single copy of the system data. However, to ensure availability in the event of server failure or when disconnected from a network, multiple copies of the data should be maintained. I discuss the trade-offs between these requirements in later chapters.
    </p>
    <article
  
  class="bg-ivory-500 scroll-mt-80 parts mt-63 md:mt-50 md:scroll-mt-90 lg:mt-45 xl:mt-45"
>
  <h2 class="border rounded-2xl shadow-lg p-4 mb-5 w-full text-center">
    1.3.3 A Wilderness Weather Station
  </h2>

  <p class="paragraph">
    To help monitor climate change and to improve the accuracy of weather forecasts in remote areas,
    the government of a country with large areas of wilderness decides to deploy several hundred
    weather stations in remote areas. These weather stations collect data from a set of instruments
    that measure temperature and pressure, sunshine, rainfall, wind speed, and wind direction.
  </p>

  <p class="paragraph mt-5">
    Wilderness weather stations are part of a larger system (Figure 1.7), which is a weather
    information system that collects data from weather stations and makes it available to other
    systems for processing.
  </p>

  <p class="paragraph mt-5">
    The systems in Figure 1.7 are:
  </p>

  <ol class="p-5 mb-3">
    <li>
      <b>The weather station system –</b> This is responsible for collecting weather data, carrying
      out some initial data processing, and transmitting it to the data management system.
    </li>
    <li>
      <b>The data management and archiving system –</b> This system collects the data from all of the
      wilderness weather stations, carries out data processing and analysis, and archives the data
      in a form that can be retrieved by other systems, such as weather forecasting systems.
    </li>
    <li>
      <b>The station maintenance system –</b> This system can communicate by satellite with all
      wilderness weather stations to monitor the health of these systems and provide reports of
      problems. It can update the embedded software in these systems. In the event of system
      problems, this system can also be used to remotely control a wilderness weather system.
    </li>
  </ol>

  <p class="paragraph mt-5">
    A weather station system is composed of multiple instruments that measure parameters like wind,
    temperature, pressure, and rainfall. Each instrument is managed by software that records data at
    frequent intervals. Since satellite bandwidth is limited, the system performs local processing
    and aggregation before transmitting data when requested. If communication fails, data is stored
    locally until a connection is restored. Weather stations are self-contained, battery-powered
    units that rely on solar or wind charging, and must withstand harsh environmental conditions and
    potential damage from wildlife.
  </p>

  <p class="paragraph mt-5">
    The station software is therefore not just concerned with data collection. It must also:
  </p>

  <ol class="p-5 mb-3">
    <li>
      Monitor the instruments, power, and communication hardware and report faults to the management
      system.
    </li>
    <li>
      Manage the system power, ensuring that batteries are charged whenever environmental conditions
      permit, but also that generators are shut down in potentially damaging weather conditions, such
      as high wind.
    </li>
    <li>
      Allow for dynamic reconfiguration where parts of the software are replaced with new versions
      and where backup instruments are switched into the system in the event of system failure.
    </li>
  </ol>

  <p class="paragraph mt-5">
    Because weather stations have to be self-contained and unattended, this means that the software
    installed is complex, even though the data collection functionality is fairly simple.
  </p>
</article>
    <figure class="figure">
              <img
                src="imagesChapter1/image9.png"
                alt="Keypoints"
                height="300px"
                class="mx-auto"
              />
            </figure>

    </main>

     <footer class="">
      
      <section class="footerSection1">

      <section class=" flex-col gap-3 hidden md:hidden lg:block xl:block">
        <img src="imagesChapter1/Lheader.png" alt="" class="w-35 h-35 rounded shadow-md  mx-auto">
        <h1 class="text-3xl font-bold text-black mt-3">SOFTWARE ENGINEERING</h1>
      </section>

      <article class="flex flex-col gap-2">
        <h1 class="text-xl bold italic">Chapter 1</h1>
        <h1>INTRODUCTION</h1>
        <a id="Terms">Terms of Use</a>
        <a id="Terms">Privacy Policy</a>
      </article>

      <article class="flex flex-col gap-2">
        <h3 class="text-xl italic">Contents</h3>
        <a class="font-bold text-blue-700" href="#part1">1.1 Professional Software Development</a>
        <a class="font-bold text-blue-700" href="#part2">1.2 Software Engineering Ethics</a>
        <a class="font-bold text-blue-700" href="#part3">1.3 Case Studies</a>
      </article>

      <article>
        <h1>Follow us on:</h1>
        <div class="flex flex-col gap-5 items-center">

    <a
      href=""
      target="_blank"
      class="text-slate-600 hover:text-blue-500 transition"
    > <img src="imagesChapter1/twitter.png" alt="" width="25px" height="25px">
    </a>

    <a
      href=""
      target="_blank"
      class="text-slate-600 hover:text-blue-700 transition"
    > <img src="imagesChapter1/IG.png" alt="" width="25px" height="25px">
    </a>

    <a
      href=""
      target="_blank"
      class="text-slate-600 hover:text-blue-600 transition"
    > <img src="imagesChapter1/Fb.png" alt="" width="25px" height="25px">
    </a>
  </div>
      </article>

      </section>

        <section class="p-5 text-center border-t bg-black text-white">
          <h3>Copyright reserved</h3>
          <h5>Developed by: Michelle Daluz</h5>
        </section>
    </footer>
  </body>
</html>